// ViewRe is a web-based code review tool.
// Copyright (C) 2025  Frank Mayer
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package view

import (
	tree_sitter "github.com/tree-sitter/go-tree-sitter"
	tree_sitter_javascript "github.com/tree-sitter/tree-sitter-javascript/bindings/go"
	tree_sitter_typescript "github.com/tree-sitter/tree-sitter-typescript/bindings/go"
	tree_sitter_go "github.com/tree-sitter/tree-sitter-go/bindings/go"
	tree_sitter_rust "github.com/tree-sitter/tree-sitter-rust/bindings/go"
	"fmt"
	"sort"
	"strconv"
	"strings"
)

var languages = map[string]*tree_sitter.Language{
	"js":  tree_sitter.NewLanguage(tree_sitter_javascript.Language()),
	"ts":  tree_sitter.NewLanguage(tree_sitter_typescript.LanguageTypescript()),
	"tsx": tree_sitter.NewLanguage(tree_sitter_typescript.LanguageTSX()),
	"go":  tree_sitter.NewLanguage(tree_sitter_go.Language()),
	"rs":  tree_sitter.NewLanguage(tree_sitter_rust.Language()),
}

func parse(code string, lang string) (*tree_sitter.Tree, error) {
	parser := tree_sitter.NewParser()
	defer parser.Close()
	if tsLang, ok := languages[lang]; !ok {
		return nil, fmt.Errorf("unknown language %q", lang)
	} else {
		parser.SetLanguage(tsLang)
	}
	tree := parser.Parse([]byte(code), nil)
	return tree, nil
}

type syntaxSpan struct {
	start       uint
	end         uint
	class       string
	kind        string
	grammarname string
}

const num = 42 / 2

func getNodeClass(nodeType string) (string, bool) {
	switch nodeType {
	case "comment", "line_comment", "block_comment":
		return "text-gray-500", true

	case "string", "string_fragment", "string_literal", "raw_string_literal", "interpreted_string_literal", "interpreted_string_literal_content", "\"", "'", "`":
		return "text-green-500", true

	case "number", "int_literal", "float_literal", "rune_literal", "chan":
		return "text-amber-500", true

	case "field_identifier":
		return "text-blue-400", true

	case "identifier":
		return "text-white", true

	case "type_identifier":
		return "text-yellow-500", true

	case "export":
		return "text-cyan-500", true

	case "import", "from", "as", "require", "package", "class", "interface", "enum", "type", "function", "fn", "fun", "func", "go", "var", "let", "const", "async", "await", "break", "case", "catch", "continue", "debugger", "default", "delete", "do", "else", "finally", "for", "if", "in", "instanceof", "new", "return", "switch", "this", "throw", "try", "typeof", "void", "while", "with", "yield":
		return "text-indigo-500", true

	case "operator", ":=", "=", "+", "-", "*", "/", "%", "==", "!=", "===", "!==", "=>", "==>", "<-", "->", "<<", ">>", "<", ">", "<=", ">=", "&&", "||", "!", "|", "&", "$":
		return "text-cyan-500", true

	case "punctuation", "{", "}", "(", ")", "[", "]", ";", "?", ":", ",", ".":
		return "text-gray-400", true

	default:
		return "text-white", false
	}
}

func collectSpans(node *tree_sitter.Node, source []byte) []syntaxSpan {
	var spans []syntaxSpan

	var traverse func(*tree_sitter.Node)
	traverse = func(n *tree_sitter.Node) {
		if n.ChildCount() == 0 {
			class, ok := getNodeClass(n.Kind())
			if !ok {
				class, ok = getNodeClass(n.GrammarName())
			}
			class += " ts-node"
			spans = append(spans, syntaxSpan{
				start:       n.StartByte(),
				end:         n.EndByte(),
				class:       class,
				grammarname: n.GrammarName(),
				kind:        n.Kind(),
			})
		} else {
			for i := uint(0); i < n.ChildCount(); i++ {
				child := n.Child(uint(i))
				traverse(child)
			}
		}
	}

	traverse(node)

	sort.Slice(spans, func(i, j int) bool {
		return spans[i].start < spans[j].start
	})

	return spans
}

func renderWithHighlighting(code []byte, spans []syntaxSpan) []highlightedSegment {
	var segments []highlightedSegment
	pos := uint(0)

	for _, span := range spans {
		if pos < span.start {
			segments = append(segments, highlightedSegment{
				text:  string(code[pos:span.start]),
				class: "text-white",
				start: pos,
				end:   span.start,
			})
		}
		segments = append(segments, highlightedSegment{
			text:        string(code[span.start:span.end]),
			class:       span.class,
			start:       span.start,
			end:         span.end,
			kind:        span.kind,
			grammarname: span.grammarname,
		})
		pos = span.end
	}

	if pos < uint(len(code)) {
		segments = append(segments, highlightedSegment{
			text:  string(code[pos:]),
			class: "text-white",
			start: pos,
			end:   uint(len(code)),
		})
	}

	return segments
}

type highlightedSegment struct {
	text        string
	class       string
	start       uint
	end         uint
	kind        string
	grammarname string
}

templ Code(code string, lang string, class ...string) {
	{{
	codeClass := "text-white whitespace-pre font-mono overflow-x-auto"
	if len(class) > 0 {
		codeClass = strings.Join(append([]string{codeClass}, class...), " ")
	}
	}}
	if tree, err := parse(code, lang); err == nil {
		<code class={ codeClass }>
			for _, segment := range renderWithHighlighting([]byte(code), collectSpans(tree.RootNode(), []byte(code))) {
				<span
					class={ segment.class }
					data-start={ strconv.Itoa(int(segment.start)) }
					data-end={ strconv.Itoa(int(segment.end)) }
					data-kind={ segment.kind }
					data-grammarname={ segment.grammarname }
				>{ segment.text }</span>
			}
		</code>
	} else {
		<pre class="text-red-700">
			<code>
				{ err.Error() }
			</code>
		</pre>
	}
}

templ CodeSample() {
	@Layout("Code Sample", "p-2 md:px-0 md:max-w-2xl md:mx-auto") {
		@Code(`// along with this program.  If not, see <https://www.gnu.org/licenses/>.

package repository

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"sync"
	"viewre/internal/db"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/config"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/transport"
)

var mutex = &sync.Mutex{}

func Diff(ctx context.Context, repo *db.Repo, baseRef, changeRef string) (string, error) {
	r, err := openGitRepo(ctx, repo)
	if err != nil {
		return "", err
	}
	auth := repo.Auth()

	baseHash, err := ensureRevision(ctx, r, baseRef, auth)
	if err != nil {
		return "", fmt.Errorf("base %s: %w", baseRef, err)
	}
	changeHash, err := ensureRevision(ctx, r, changeRef, auth)
	if err != nil {
		return "", fmt.Errorf("change %s: %w", changeRef, err)
	}

	baseCommit, err := r.CommitObject(baseHash)
	if err != nil {
		return "", fmt.Errorf("load base %s: %w", baseHash, err)
	}
	changeCommit, err := r.CommitObject(changeHash)
	if err != nil {
		return "", fmt.Errorf("load change %s: %w", changeHash, err)
	}

	patch, err := baseCommit.PatchContext(ctx, changeCommit)
	if err != nil {
		return "", fmt.Errorf("diff %s..%s: %w", baseRef, changeRef, err)
	}
	return patch.String(), nil
}

func ensureRevision(ctx context.Context, r *git.Repository, rev string, auth transport.AuthMethod) (plumbing.Hash, error) {
	h, err := r.ResolveRevision(plumbing.Revision(rev))
	if err == nil {
		return *h, nil
	}
	if ferr := r.FetchContext(ctx, &git.FetchOptions{
		RemoteName: "origin",
		Auth:       auth,
		Force:      true,
		RefSpecs: []config.RefSpec{
			"+refs/heads/*:refs/remotes/origin/*",
			"+refs/tags/*:refs/tags/*",
		},
	}); ferr != nil && ferr != git.NoErrAlreadyUpToDate {
		return plumbing.ZeroHash, fmt.Errorf("fetch failed: %w", ferr)
	}
	h, err = r.ResolveRevision(plumbing.Revision(rev))
	if err != nil {
		return plumbing.ZeroHash, fmt.Errorf("resolve %q: %w", rev, err)
	}
	return *h, nil
}

func openGitRepo(ctx context.Context, repo *db.Repo) (*git.Repository, error) {
	repoPath := filepath.Join(tempDir, repo.Name)
	if err := ensureGitRepoExists(ctx, repo); err != nil {
		return nil, err
	}
	return git.PlainOpen(repoPath)
}

func ensureGitRepoExists(ctx context.Context, repo *db.Repo) error {
	repoPath := filepath.Join(tempDir, repo.Name)
	if _, err := os.Stat(repoPath); os.IsNotExist(err) {
		if err := os.MkdirAll(repoPath, 0777); err != nil {
			return errors.Join(fmt.Errorf("failed to create directory %s", repoPath), err)
		}
		if err := cloneGitRepo(ctx, repo); err != nil {
			return errors.Join(fmt.Errorf("failed to clone git repository %s", repo.Url), err)
		}
		return nil
	} else {
		return nil
	}
}

func cloneGitRepo(ctx context.Context, repo *db.Repo) error {
	repoPath := filepath.Join(tempDir, repo.Name)
	_, err := git.PlainCloneContext(ctx, repoPath, false, &git.CloneOptions{
		URL:  repo.Url,
		Auth: repo.Auth(),
	})
	if err != nil {
		return errors.Join(fmt.Errorf("failed to clone git repository %s into %s", repo.Url, repoPath), err)
	}
	return nil
}
`, "go")
	}
}
